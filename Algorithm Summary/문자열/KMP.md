# KMP(Knuth-Morris-Pratt) 알고리즘

- 앞쪽 부터 비교 한다.
- 불일치가 발생한 텍스트 문자열의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
- 즉 앞에까지 맞은게 있다면, 그 정보를 최대한 다시 활용

```
ex) S="aaaaaaaaaab", W="aaaaab"에서 aaaaa는 앞에서 맞았다!
```

- 패턴을 전처리하여 부분일치 테이블 배열 pi[k]를 구해서 잘못된 시작을 최소화함
  - pi[k]: 처음부터 k인덱스까지를 끝으로 하는 부분 문자열에서 일치하는 **접두사**와 **접미사**가 일치하는 **최대길이**
- 틀린부분 앞에 있는것들이랑 앞에서 있는 부분끼리 같은 패턴을 보이는가?
- 시간 복잡도 O(M+N)

## 패턴을 이용한 부분일치 테이블 배열 작성

- 가장 중요한것은 일치한 부분에서 뒤에서부터 n개의 길이가, 앞에서부터 n개까지 일치하는 경우중에 최대길이를 찾아야한다.
- 매칭에 실패했을때 패턴포인터가 돌아갈 곳을 게산
- 패턴의 0번째 인덱스를 제외한 각 인덱스마다 맨 앞부터 해당 인덱스까지의 부분 문자열중 접두사와 접미사가 일치하는 최대길이로 계산해 측정

## 부분일치 테이블 만들기

```java
// 부분일치테이블 만들기 
		int[] pi = new int[pLength];
	    for(int i=1, j=0; i<pLength; i++){// i:접미사 포인터(i=1부터 시작: 부분일치테이블를 만드는게 목적이므로 첫글자 틀리면 0위치로 가야한다.), j:접두사 포인터
	        while(j > 0 && pattern[i] != pattern[j]) j = pi[j-1];

	        if(pattern[i] == pattern[j]) pi[i] = ++j;
	        else pi[i] = 0;
	    }
```
