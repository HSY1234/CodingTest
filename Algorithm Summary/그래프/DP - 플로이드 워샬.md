# 플로이드 워샬

1. 모든 쌍 최단 경로
2. 양수, 음수 가중치 상관 X
3. DP 알고리즘
4. O(N^3)
5. 3중 for 문 (경유지 - 출발 - 도착)
6. 다익스트라와 시간복자도는 동일해도 구현이 훨씬 간단

## 원리

A=> B로가는 최단경로 위에 K 정점이 있을때, 해당 경로의 부분 경로인 A=>K 도 최단이고, K=>B도 최단거리이다.

## DP 접근 순서

0. 그래프에 정점이 2개일때, 경로는 1가지 => 직행
1. 그래프에 정점이 3개일때, 한곳으로 가는 경로는 2가지다. 직행 or 거쳐가기 =>이중 짧은것
2. 이렇게 정점을 하나씩 늘려가면서, 추가된 정점을 경유지로 거치는게 유리하면 업데이트, 아니면 유지

- DP를 위한 부분문제로 정의해보기  
  Dijk = 정점 {1,2,3,....,k}만을 정점으로 사용해(고려했다는거지 전부 다 지나오는 경로가 아님) 정점 i부터 j까지 가는 가장 짧은 경로의 길이 (큰 이차원 배열 N\*N i,j로 해놓고 채워나가기)  
  k!=i, k!=j 이고, k=0이며느 정점 0은 그래프에 없으므로 어떤 정점도 경유하지않는 간선 (i,j)의 가중치이다.  
  Dij1은 정점 1을 경유하여 j로 가는 경로와 i에서 j로 직접가는 경로중 더 짧은 거리.  
  Dij2는 그러면 Dij1(원래 최적해) 과 Di21 + D2j1(새 경유지 거치는것) 중 더 작은것이 될것이다.
  이런식으로 정점을 계속 추가해가면서 업데이트 해간다.

## 수도코드

`D[N][N]` 배열의 인접하지 않은곳은 매우 큰수(덧셈연산이 있다면 오버플로우 안될 그런 큰 값), 인접한건 그 값으로 업데이트 하고 시작

```
D[i][j] = 정점 i에서 j로의 최소비용
Pair(D[][])
  For k in 1~n => 경유지 추가!!
    For i in 1~n (단 i는 k와 같지 않음) => 출발지
      For j in 1~n (단 j는 i,k와 같지 않음) => 도착지
        D[i][j] = min(D[i][k]+D[k][j], D[i][j])

```

for문의 순서가 매우 중요하다!!!  
경유지가 가장 밖에 있는 For문이어야한다. 그래야 한쌍씩 for문을 돌릴수 있다(경-출-도)

## 구현

```java
for(int k=0; k<N; ++k) {
			for(int i=0; i<N; ++i) { // 경유지의 집합에 i가 점점 추가된다고 생각하면된다.
				if(i==k) continue; // 출발지와 경유지가 같다면 다음 출발지
				for(int j=0; j<N; ++j) {
					if(i==j || k==j) continue; // 경유지와 목적지가 같거나 출발지가 곧 목적지라면 패스
					if(adjMatrix[i][j] > adjMatrix[i][k]+adjMatrix[k][j]) {
						adjMatrix[i][j] = adjMatrix[i][k]+adjMatrix[k][j];
					}
				}
			}
		}
```

## 해설

k=0 0정점만을 경유지로 했을때  
k=1 0,1정점을 고려했을때(실제 계산에는 0이 이미 최소값으로 업데이트되어있으므로 1만고려)
k=2 0,1,2정점을 고려했을때(실제 계산에는 0,1이 이미 최소값으로 업데이트되어있으므로 2만고려)

이런식으로 점점 경유지의 집합에 속한 정점수를 늘려간다. 단지 추가된 정점만을 계산하는 이유는 이미 i-j에서 그전 정점까지 지나는 최소값이 다 고려되었기 때문이다.
