# 모든 쌍 최단 경로

어떻게 구할 것인가?

1. 다익스트라: 양의 가중치, 단일 출발점, 다른 모든 정점 최단 경로

- 모든 쌍 최단을 구하는 방법
  - 양의 가중치만 있다면? 모든 점에서 다익스트라를 돌린다! O(N^2)\*O(N) => N^3
  - 최적화된 다익스트라(PQ랑 인접 리스트?)는 O(N^2logN) => 정확히는 E,V

2. 플로이드 워샬 - DP

- 3중 for문
- 상대적으로 구현이 매우 쉽다
- 양의 가중치가 아니라도 가능

## Brute Force

- 한 정점에서 다른 정점으로의 모든 경로를 구한 뒤, 그들 중에서 최단 경로를 찾는다.
- 그래프가 n개의 정점을 가지고 있고, 완전 그래프라고 가정
- 한 정점에서 어떤 정점으로 가는 경로들을 다 모아 보면, 그 경로들 중에서 나머지 모든 정점을 한번씩은 꼭 거쳐서 가는 경로들도 포함되어 있는데, 그 경로들의 수만 우선 계산해 보자.
- i에서 출발하여 처음에 도착할 수 있는 정점의 가지 수는 n-2개이고, 그중에 하나를 선택하면, 그 다음에 도착할 수 있는 정점의 가지 수는 n-3개이고, 이렇게 계속하여 계산해 보면, 총 경로의 개수는 (n-2)!이 된다. (단순 순열과 같아짐)
- 이경로의 개수만 보아도 지수보다 훨씬 크므로, 비효율적

## DP로 접근해보자

- 각 정점을 시작 정점으로 다익스트라 알고리즘을 수행
- 시간복잡도 O(N^3)
- Warshall은 그래프에서 모든 쌍의 경로 존재 여부를 찾아내는 동적 알고리즘을 제안, Floyd는 이를 변형해서 모든 쌍 최단 경로를 찾는 알고리즘을 고안
- 모든 쌍 최단 경로를 찾는 DP 알고리즘을 플로이드-워샬이라고 하게 되었다.

## 플로이드 워샬

- 시간 복잡도 O(N^3)
- 다익스트라와 시간복자도는 동일해도 구현이 훨씬 간단

## DP 접근 순서

0. 그래프에 정점이 2개일때, 경로는 1가지 => 직행
1. 그래프에 정점이 3개일때, 한곳으로 가는 경로는 2가지다. 직행 or 거쳐가기 =>이중 짧은것
2. 이렇게 정점을 하나씩 늘려가면서, 추가된 정점을 경유지로 거치는게 유리하면 업데이트, 아니면 유지

- DP를 위한 부분문제로 정의해보기  
  Dijk = 정점 {1,2,3,....,k}만을 정점으로 사용해(고려했다는거지 전부 다 지나오는 경로가 아님) 정점 i부터 j까지 가는 가장 짧은 경로의 길이 (큰 이차원 배열 i,j로 해놓고 채워나가기)  
  k!=i, k!=j 이고, k=0이며느 정점 0은 그래프에 없으므로 어떤 정점도 경유하지않는 간선 (i,j)의 가중치이다.  
  Dij1은 정점 1을 경유하여 j로 가는 경로와 i에서 j로 직접가는 경로중 더 짧은 거리.  
  Dij2는 그러면 Dij1(원래 최적해) 과 Di21 + D2j1(새 경유지 거치는것) 중 더 작은것이 될것이다.
  이런식으로 정점을 계속 추가해가면서 업데이트 해간다.

## 수도코드

```
D[i][j] = 정점 i에서 j로의 최소비용
Pair(D[][])
  For k in 1~n => 경유지 추가!!
    For i in 1~n (단 i는 k와 같지 않음) => 출발지
      For j in 1~n (단 j는 i,k와 같지 않음) => 도착지
        D[i][j] = min(D[i][k]+D[k][j], D[i][j])

```

for문의 순서가 매우 중요하다!!!  
경유지가 가장 밖에 있는 For문이어야한다. 그래야 한쌍씩 for문을 돌릴수 있다(경-출-도)
