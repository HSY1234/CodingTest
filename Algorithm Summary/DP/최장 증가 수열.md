# 최장 증가 수열(Longest Increasing Subsequence)

어떤 숫자들의 수열이 왼쪽에서 오른쪽으로 나열되어 있을때, 배열의 순서를 유지하면서 크기가 점진적으로 커지는 가장 긴 부분 수열의 길이는 얼마인가?

ex) 3 2 6 4 5 1  
2 4 5  
3 4 5  
최대 길이는 3

## Brute-force

- 수열의 모든 부분 집합을 구하여 부분집합이 증가수열인지 판단하고 가장 긴값 구하기
- 부분집합이 긴거 부터 찾는게 좋다(긴게 정답이니까)
- 너무 오래걸림 O(2^n)

## DP 최초 접근

- 입력: 숫자열 a1,a2,a3....,an
- LIS(i): a1~ai에서 최장 부분 수열 길이
- 점화식! LIS(i)를 LIS로 표현가능하지 않을까?
- Case1: LIS(i)가 ai를 포함하지 않는다 => LIS(i) = LIS(i-1) ? 이건 완전히 틀림
- Case2: LIS(i)가 ai를 포함한다. => LIS(i) = LIS(i-1)+1 ? 틀렸다! ai가 최적해로 들어가는지 확정 불가

## DP 새로운 접근

- LIS(i)는 **ai가 반드시 포함된** 최장 증가 수열의 길이라고 정의를 바꾼다.
- 증가 수열의 관계인 aj<ai 인 aj를 찾는다.
- j값을 알 수 없으므로 모두 검색해야한다.
- 그 중 최대값을 찾아 1 증가시켜 LIS(i)에 저장한다.
- 최종적으로 LIS()중에서 최대 값을 찾는다.

```
For i in 1~n
  LIS[i] =1
  FOR j in 1~i-1
    IF aj < ai && LIS[i] < 1+ LIS[j]
      LIS[i] = 1 + LIS[j]
RETURN max LIS[]
```

=> 결국 전부 비교라 O(n^2)

```java
for(int i =0; i< N; i++){
  LIS[i] =1;
  for(int j=0; j<i;j++){
    if(arr[j]<arr[i] && LIS[i] <LIS[j]+1){
      LIS[i] = LIS[j]+1;
    }
  }
}

//LIS전체 중 제일 큰거 출력하면됨
```

## 이진 검색 활용 (O(nlogn))

- 동적테이블 생성
- dp[k]: 길이 k의 증가 수열에 대하여 가장 작은 값을 dp[k]에 저장 => 각 원소별로
- 각 위치에서 dp[]를 갱신하기 위해 이진 검색을 수행한다.

```
8 2 4 3 6 11 7 10 14 5
8 2 2 2 2  2 2  2  2 2 dp[1] => 각 좌표별로 길이 1의 그자리에올수있는 최소값 원소
    4 3 3  3 3  3  3 3 dp[2] => 각 좌표별로 길이 2의 그자리에올수있는 최소값 원소
        6  6 6  6  6 5 dp[3] => 각 좌표별로 길이 3의 그자리에올수있는 최소값 원소
          11 7  7  7 7 dp[4] => 각 좌표별로 길이 4의 그자리에올수있는 최소값 원소
               10 10 10 dp[5]
                  14 14 dp[6]
정답 14가 있는 6(dp 길이 최대값)
```

이 그래프는 세로로 봐야한다. 앞에서 부터 차례대로 자신이 삽입될 위치를 이진 탐색으로 찾는다.  
자기 차례때 있는 배열이 자기가 가장 큰 값보다 더 크다면 뒤에 붙여주고,  
만약 제일 크지 않다면 이진탐색으로 자기가 들어갈 자리 (나랑 제일 가까우면서 나보다 큰 값 => 나로 변경)를 찾아 들어간다.
