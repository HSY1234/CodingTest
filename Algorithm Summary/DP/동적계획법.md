# 동적계획법(Dynamic Programming)

- 동적 계획법은 그리디 알고리즘과 같이 **최적화 문제**를 해결하는 알고리즘이다.
- 동적 계획법은 먼저 작은 부분 문제들의 해를 구하고 이들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 문제를 해결하는 알고리즘 기법이다.
- 처음부터 f(n)을 구하는게 아니고, 더 작은 f(k)를 해결하고 이를 이용해 f(n)을 해결한다.

피보나치 재귀호출로 함수를 구현하면 중복호출로 인한 계산이 매우 많아진다 => 매번 중복되는 계산을 다시 할 필요가 없지 않나? => **메모이제이션(memoiztion)** 등장 (메모리제이션 아님!!)

아이디어: fibo(n)을 또 계산하지말고 한번 계산하면 어딘가 저장해두면 바로 다시 쓸수있지않을까?

## 동적 계획법은 언제 써야하는가?

1. 큰 크기의 문제를 작은 크기의 문제로 해결할수 있는가?
2. 큰 크기의 문제를 푸는 방법이 작은 문제를 푸는 방법에 동일하게 적용되는가?
3. 작은 문제의 답이 큰 문제의 답의 부분이 될수 있느가?

## 동적 계획법의 조건

- 중복 부분문제 구조 => 중복 계산이 존재하는가?
- 최적 부분문제 구조 => 작은 문제로 쪼개지고, 작은 문제가 큰 문제에 속하는가?

## 최적 부분문제구조(Optimal substructure)

- 동적 계획법이 최적화에 대한 어느 문제에나 적용 X, 주어진 문제가 최적화의 원칙을 만족해야한다.
- 최적화의 원칙이란 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 한다는 것이다. 동적계획법은 큰 문제의 최적 해를 작은 문제의 최적해 들을 이용해서 구하기 떄문에 만약 큰 문제의 최적해가 작은 문제들의 최적해들로 구성되지 않는다면 적용 불가

## 중복 부분문제 구조(Overlapping subproblems)

- Dp는 큰 문제를 이루는 작은 문제들을 먼저 해결하고 작은 무제들의 최적해를 이용하여 순환적으로 큰 문제를 해결한다. => 보통 점화식으로 표현 가능
- DP는 문제의 순환적인 성질 때문에 이전 계산되었던 작은 문제의 해가 다른 어딘가에서 필요하게 되고, 이를 위해 어떤 저장 공간에 이를 저장한다.
- 그리고 이렇게 저장된 해들이 다시 필요할 때 마다 해를 얻기 위해 다시 문제를 재계산하지 않고 저장된 값을 가져와 중복 계산을 피한다.

## 메모이제이션(memoiztzion)

- 메모이제이션은 이전에 계산한 값을 메모리에 저장해 매번 다시 계산하지 않도록 해서 실행속도를 빠르게 하는 동적계획법의 **핵심 개념**이다.
- 기억하기 위한 저장공간은 꼭 1차원 배열일 필요없다. 필요에 따라 2차원 배열, 다른 자료구조(Map, 연결리스트 등) 다양하게 가능하다. 그러나 아무래도 배열이 값 접근이 제일 빠르다.

- 단점: 추가적인 메모리 공간 필요, 재귀 함수 호출로 시스템 호출 스택을 사용하게되어 속도 저하 or 오버플로우 발생

## 피보나치

- 메모이제이션을 사용하면 실행시간이 O(n)이 된다.
- 저장한 배열에 값이 있으면 바로 그 값을 리턴 없다면 계산 시작

```java
int [] memo = new int[100];
Arrays.fill(memo,-1);
memo[0] =1;
memo[1] =1;
public int fibo(int n){
  if(n>=2 && memo[n] == -1){
    memo[n]=fibo(n-1)+fibo(n-2);
  }
  return memo[n];
}

```

## 조합

nCr = n-1Cr + n-1Cr-1
