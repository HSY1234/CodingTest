# 동적계획법(Dynamic Programming)

- 동적 계획법은 그리디 알고리즘과 같이 **최적화 문제**를 해결하는 알고리즘이다.
- 동적 계획법은 먼저 작은 부분 문제들의 해를 구하고 이들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 문제를 해결하는 알고리즘 기법이다.
- 처음부터 f(n)을 구하는게 아니고, 더 작은 f(k)를 해결하고 이를 이용해 f(n)을 해결한다.

피보나치 재귀호출로 함수를 구현하면 중복호출로 인한 계산이 매우 많아진다 => 매번 중복되는 계산을 다시 할 필요가 없지 않나? => **메모이제이션(memoiztion)** 등장 (메모리제이션 아님!!)

아이디어: fibo(n)을 또 계산하지말고 한번 계산하면 어딘가 저장해두면 바로 다시 쓸수있지않을까?

## 동적 계획법은 언제 써야하는가?

1. 큰 크기의 문제를 작은 크기의 문제로 해결할수 있는가?
2. 큰 크기의 문제를 푸는 방법이 작은 문제를 푸는 방법에 동일하게 적용되는가?
3. 작은 문제의 답이 큰 문제의 답의 부분이 될수 있느가?

## 동적 계획법의 조건

- 중복 부분문제 구조 => 중복 계산이 존재하는가?
- 최적 부분문제 구조 => 작은 문제로 쪼개지고, 작은 문제가 큰 문제에 속하는가?

## 최적 부분문제구조(Optimal substructure)

- 동적 계획법이 최적화에 대한 어느 문제에나 적용 X, 주어진 문제가 최적화의 원칙을 만족해야한다.
- 최적화의 원칙이란 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 한다는 것이다. 동적계획법은 큰 문제의 최적 해를 작은 문제의 최적해 들을 이용해서 구하기 떄문에 만약 큰 문제의 최적해가 작은 문제들의 최적해들로 구성되지 않는다면 적용 불가

## 중복 부분문제 구조(Overlapping subproblems)

- Dp는 큰 문제를 이루는 작은 문제들을 먼저 해결하고 작은 무제들의 최적해를 이용하여 순환적으로 큰 문제를 해결한다. => 보통 점화식으로 표현 가능
- DP는 문제의 순환적인 성질 때문에 이전 계산되었던 작은 문제의 해가 다른 어딘가에서 필요하게 되고, 이를 위해 어떤 저장 공간에 이를 저장한다.
- 그리고 이렇게 저장된 해들이 다시 필요할 때 마다 해를 얻기 위해 다시 문제를 재계산하지 않고 저장된 값을 가져와 중복 계산을 피한다.

## 메모이제이션(memoiztzion)

- 메모이제이션은 이전에 계산한 값을 메모리에 저장해 매번 다시 계산하지 않도록 해서 실행속도를 빠르게 하는 동적계획법의 **핵심 개념**이다.
- 기억하기 위한 저장공간은 꼭 1차원 배열일 필요없다. 필요에 따라 2차원 배열, 다른 자료구조(Map, 연결리스트 등) 다양하게 가능하다. 그러나 아무래도 배열이 값 접근이 제일 빠르다.

- 단점: 추가적인 메모리 공간 필요, 재귀 함수 호출로 시스템 호출 스택을 사용하게되어 속도 저하 or 오버플로우 발생

## 피보나치

- 메모이제이션을 사용하면 실행시간이 O(n)이 된다.
- 저장한 배열에 값이 있으면 바로 그 값을 리턴 없다면 계산 시작

```java
int [] memo = new int[100];
Arrays.fill(memo,-1);
memo[0] =1;
memo[1] =1;
public int fibo(int n){
  if(n>=2 && memo[n] == -1){
    memo[n]=fibo(n-1)+fibo(n-2);
  }
  return memo[n];
}

```

## 조합

nCr = n-1Cr + n-1Cr-1

## 적용불가 예시

최장경로 문제

- A에서 D까지 최장 경로는?
- A-C, C-D 각각 최장 경로를 찾으면 된다? => 부분의 최장의 합이 최장이라는 보장이 없음

## 분할정복 VS DP

분할정복

- 연관없는 부분 문제로 분할
- 부분 문제를 재귀로 해결
- 부분 문제의 해를 결합한다.

DP

- 부분 문제들이 연관이 없으면 적용 불가. 즉 부분 문제들은 더 작은 부분 무제들을 공유한다.
- 모든 부분 문제를 한번만 계산하고 결과를 저장하여 재사용

가장 결정적인 차이는 연관이 있느냐 없느냐! 예를 들어 병합 정렬, 퀵정렬은 부분으로 나누어 풀고 각각 재귀함수로 구한것을 합친다.  
DP와 비슷해 보이지만, 정렬 각 부분을 계산하지 않는다고 지금하는 부분을 계산하지 못하는건 아니다. 즉 분할정복으로 각 분할의 풀이 방법이 똑같을수는 있지만, 이는 풀이 방법이 같을뿐 서로 연관이 있는건 아니다.  
DP는 작은 부분이 계산이 안되면 다른곳에서 문제가 해결이 안된다.

분할정복은 하향식, DP는 상향식이다.

## 적용 접근 방법

- 문제를 부분 문제로 나눈다
- 부분 문제의 최적해 값에 기반하여 문제의 최적해값을 정의한다.(점화식)
- 상향식방법으로 최적해의 값을 계산하라
